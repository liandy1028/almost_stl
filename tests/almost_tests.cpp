#include "DuckTest.h"

namespace DuckTest {
template <typename T>
  requires requires(T v) {
    v.begin();
    v.end();
  } && (!std::is_same_v<std::remove_cvref_t<T>, std::string>)
std::ostream& operator<<(std::ostream& os, const T& v) {
  for (const auto& elem : v) os << elem << " ";
  os << "(capacity:" << v.capacity() << ")";
  return os;
}
}  // namespace DuckTest

DUCK_TEST(Constructor, Sized) {
  Vector<T<>> v(3);
  LOG(v, "\n");
}

DUCK_TEST(Constructor, SizedWithValue) {
  Vector<T<>> v(3, T<>(42));
  LOG(v, "\n");
}

DUCK_TEST(Constructor, InitializerList) {
  Vector<T<>> v{T<>(1), T<>(2), T<>(3)};
  LOG(v, "\n");
}

DUCK_TEST(Constructor, Iterator) {
  std::vector<T<>> src{T<>(1), T<>(2), T<>(3)};
  Vector<T<>> v(src.begin(), src.end());
  LOG(v, "\n");
}

DUCK_TEST(Constructor, Copy) {
  Vector<T<>> v1(3, T<>(42));
  Vector<T<>> v2 = v1;
  LOG(v1, "\n");
  LOG(v2, "\n");
}

DUCK_TEST(Constructor, Move) {
  Vector<T<>> v1(3, T<>(42));
  Vector<T<>> v2 = std::move(v1);
  LOG(v1, "\n");
  LOG(v2, "\n");
}

DUCK_TEST(Assignment, SelfCopy) {
  Vector<T<>> v(2);
  v = v;
  LOG(v, "\n");
}

DUCK_TEST(Assignment, SelfMove) {
  Vector<T<>> v(2);
  v = std::move(v);
  LOG(v, "\n");
}

DUCK_TEST(Assignment, CopyDoesNotReallocate) {
  Vector<T<>> v1(3);
  Vector<T<>> v2(2);
  v1 = v2;
  LOG("v1: ", v1, "\n");
}

DUCK_TEST(Assignment, CopyReallocates) {
  Vector<T<>> v1(2);
  Vector<T<>> v2(3);
  v1 = v2;
  LOG("v1: ", v1, "\n");
  LOG("v2: ", v2, "\n");
}

DUCK_TEST(Assignment, Move) {
  Vector<T<>> v1(3);
  Vector<T<>> v2(2);
  v1 = std::move(v2);
  LOG("v1: ", v1, "\n");
  LOG("v2: ", v2, "\n");
}

DUCK_TEST(Clear, Basic) {
  Vector<T<>> v(3);
  LOG("Before clear: ", v, "\n");
  v.clear();
  LOG("After clear: ", v, "\n");
}

DUCK_TEST(Reserve, MoveObjects) {
  Vector<T<>> v{1, 2, 3};
  v.reserve(10);
  LOG(v, "\n");
}

// =============================================================================
// AI TESTS
// These tests were generated by AI
// =============================================================================

// =============================================================================
// 1. SIMPLE & BASIC API
// =============================================================================

DUCK_TEST(Simple, InitialState) {
  Vector<T<>> v;
  LOG("Size: ", v.size(), " Capacity: ", v.capacity(), " Empty: ", v.empty(),
      "\n");
}

DUCK_TEST(Simple, PushAndAccess) {
  Vector<T<>> v;
  v.push_back(T<>(10));
  v.push_back(T<>(20));
  LOG("Front: ", v.front(), " Back: ", v.back(), "\n");
  LOG("Index 0: ", v[0], " Index 1: ", v[1], "\n");
  if (v.data() == &v[0]) LOG("data() pointer is valid\n");
}

DUCK_TEST(Simple, ResizeBasic) {
  Vector<T<>> v;
  LOG("Resize up (default construct)\n");
  v.resize(3);
  LOG("Resize up (value 99)\n");
  v.resize(5, T<>(99));
  LOG("Resize down to 2\n");
  v.resize(2);
}

DUCK_TEST(Simple, ClearEmpty) {
  Vector<T<>> v(5);
  LOG("Size before clear: ", v.size(), "\n");
  v.clear();
  LOG("Size after clear: ", v.size(), " Empty: ", v.empty(), "\n");
}

// =============================================================================
// 2. LIFECYCLE (THE BIG FIVE)
// =============================================================================

DUCK_TEST(Lifecycle, Construction) {
  LOG("--- Sized Construction ---\n");
  Vector<T<>> v1(3);

  LOG("--- Copy Construction ---\n");
  Vector<T<>> v2 = v1;

  LOG("--- Move Construction ---\n");
  Vector<T<>> v3 = std::move(v1);
}

DUCK_TEST(Lifecycle, Assignment) {
  Vector<T<>> v1, v2;
  v1.push_back(T<>(1));
  v2.push_back(T<>(2));

  LOG("--- Copy Assignment ---\n");
  v1 = v2;

  LOG("--- Move Assignment ---\n");
  Vector<T<>> v3;
  v3 = std::move(v1);
}

DUCK_TEST(Lifecycle, SelfAssignment) {
  Vector<T<>> v;
  v.push_back(T<>(1));
  LOG("Self-copy\n");
  v = v;
  LOG("Self-move\n");
  v = std::move(v);
}

DUCK_TEST(Lifecycle, ShrinkToFit) {
  Vector<T<>> v;
  v.reserve(100);
  v.push_back(T<>(1));
  LOG("Capacity before: ", v.capacity(), "\n");
  v.shrink_to_fit();
  LOG("Capacity after: ", v.capacity(), "\n");
}

// =============================================================================
// 3. NOEXCEPT TRAIT LOGIC
// =============================================================================

DUCK_TEST(Traits, ReallocationCopyVsMove) {
  LOG("--- Scenario: Move is noexcept (Should MOVE) ---\n");
  {
    using SafeT = T<{.moveConstructorCanThrow = false}>;
    Vector<SafeT> v;
    v.push_back(SafeT(1));
    v.push_back(SafeT(2));
    v.reserve(v.capacity() + 10);
  }

  LOG("\n--- Scenario: Move can throw (Should COPY for Safety) ---\n");
  {
    using RiskyT = T<{.moveConstructorCanThrow = true}>;
    Vector<RiskyT> v;
    v.push_back(RiskyT(1));
    v.push_back(RiskyT(2));
    v.reserve(v.capacity() + 10);
  }
}

// =============================================================================
// 4. MODIFIERS & SHIFTING
// =============================================================================

DUCK_TEST(Modifiers, PopBack) {
  Vector<T<>> v;
  v.push_back(T<>(1));
  v.pop_back();  // Should destroy 1 element
  LOG("Size after pop: ", v.size(), "\n");
}

DUCK_TEST(Modifiers, InsertBoundaries) {
  Vector<T<>> v;
  v.push_back(T<>(10));
  LOG("Insert begin\n");
  v.insert(v.begin(), T<>(0));
  LOG("Insert end\n");
  v.insert(v.end(), T<>(20));
}

DUCK_TEST(Modifiers, InsertBoundaries2) {
  Vector<T<>> v;
  v.push_back(T<>(10));
  LOG("Insert begin\n");
  v.insert(v.begin(), T<>(0));
  LOG("Insert end\n");
  v.push_back(T<>(20));
}

DUCK_TEST(Modifiers, EraseSingleAndRange) {
  Vector<T<>> v;
  for (int i = 0; i < 5; ++i) v.push_back(T<>(i));

  LOG("Erase front\n");
  v.erase(v.begin());

  LOG("Erase range [1, 3)\n");
  v.erase(v.begin() + 1, v.begin() + 3);
}

DUCK_TEST(Modifiers, EmplaceBack) {
  Vector<T<>> v;
  v.emplace_back(123);  // Uses T(int)
  LOG("Back: ", v.back(), "\n");
}

// =============================================================================
// 5. STRESS & EXCEPTIONS
// =============================================================================

DUCK_TEST(Stress, Growth) {
  Vector<T<>> v;
  LOG("Pushing 20 elements to observe growth factor strategy\n");
  for (int i = 0; i < 20; ++i) {
    v.push_back(T<>(i));
    LOG("Cap: ", v.capacity(), " ");
  }
  LOG("\n");
}

DUCK_TEST(Stress, MoveOnlyType) {
  using MoveOnlyT =
      T<{.enableCopyConstructor = false, .enableCopyAssignment = false}>;
  Vector<MoveOnlyT> v;
  v.push_back(MoveOnlyT(1));
  v.reserve(10);  // Must move, cannot copy
  LOG("Move-only vector size: ", v.size(), "\n");
}

DUCK_TEST(Exception, ThrowOnCopy) {
  using ThrowyT = T<{.copyConstructorCanThrow = true}>;
  Vector<ThrowyT> v1;
  v1.push_back(ThrowyT(1));

  LOG("Attempting throwing copy construction\n");
  try {
    Vector<ThrowyT> v2 = v1;
  } catch (...) {
    LOG("Caught expected exception\n");
  }
}

// =============================================================================
// AI TESTS: SYSTEMATIC VALIDATION
// =============================================================================

// 1. REALLOCATION AND OVERLAP
DUCK_TEST(Modifiers, InsertAtCapacity) {
  Vector<T<>> v;
  v.reserve(2);
  v.push_back(T<>(10));
  v.push_back(T<>(20));
  LOG("Before insert: ", v, "\n");

  // Triggers reallocation + shifting
  v.insert(v.begin() + 1, T<>(15));
  LOG("After insert: ", v, "\n");
}

// 2. RANGE ERASE DYNAMICS
DUCK_TEST(Modifiers, EraseRangeEnd) {
  Vector<T<>> v{1, 2, 3, 4, 5};
  // Erase from middle to end
  auto it = v.erase(v.begin() + 2, v.end());
  LOG("After range erase: ", v, "\n");
  if (it == v.end()) LOG("Returned end iterator\n");
}

DUCK_TEST(Modifiers, EraseEntireVector) {
  Vector<T<>> v{1, 2, 3};
  v.erase(v.begin(), v.end());
  LOG("Empty after erase: ", v, " Size: ", v.size(), "\n");
}

// 3. RESIZE CORNER CASES
DUCK_TEST(Resize, ShrinkAndGrow) {
  Vector<T<>> v{1, 2, 3, 4, 5};
  LOG("Original: ", v, "\n");

  v.resize(2);
  LOG("Shrunk to 2: ", v, "\n");

  v.resize(4, T<>(99));
  LOG("Grown back to 4: ", v, "\n");

  v.resize(10);
  LOG("Grown to 10 (default): ", v, "\n");
}

// 4. ASSIGNMENT FLAVORS
DUCK_TEST(Assignment, InitializerListOverwriting) {
  Vector<T<>> v(10, T<>(1));
  LOG("Before IL assignment: ", v, "\n");

  v = {7, 8, 9};
  LOG("After IL assignment: ", v, "\n");
}

// 5. DATA STABILITY
DUCK_TEST(Access, DataPointerStability) {
  Vector<T<>> v{1, 2, 3};
  const T<>* ptr = v.data();
  LOG("First element via data(): ", *ptr, "\n");

  v.push_back(T<>(4));  // May reallocate
  if (v.data() != ptr) {
    LOG("Reallocation changed data pointer\n");
  }
  LOG("Vector after growth: ", v, "\n");
}

// 6. POP_BACK ON SINGLETON
DUCK_TEST(Modifiers, PopBackToEmpty) {
  Vector<T<>> v;
  v.push_back(T<>(42));
  LOG("Before pop: ", v, "\n");
  v.pop_back();
  LOG("After pop: ", v, " Size: ", v.size(), "\n");
}

// 7. ITERATOR ARITHMETIC LOGGING
DUCK_TEST(Iterators, Distances) {
  Vector<T<>> v{10, 20, 30, 40, 50};
  auto first = v.begin();
  auto last = v.end();
  auto mid = first + (last - first) / 2;

  LOG("Mid element: ", *mid, "\n");
  LOG("Distance from start: ", (mid - first), "\n");
  LOG("Distance to end: ", (last - mid), "\n");
}

// 8. EMPLACE VS PUSH
DUCK_TEST(Modifiers, EmplaceBackMultipleArgs) {
  // Assuming T<> can be constructed from an int
  Vector<T<>> v;
  v.emplace_back(1);
  v.emplace_back(2);
  LOG("Emplaced: ", v, "\n");
}

// 9. SHRINK TO FIT (NON-BINDING BUT TESTABLE)
DUCK_TEST(Memory, ShrinkToFitEmpty) {
  Vector<T<>> v;
  v.reserve(100);
  LOG("Cap before: ", v.capacity(), "\n");
  v.shrink_to_fit();
  LOG("Cap after: ", v.capacity(), "\n");
}

// 10. REPETITIVE PUSH_BACK (GROWTH STRATEGY)
DUCK_TEST(Stress, InterleavedPushPop) {
  Vector<T<>> v;
  for (int i = 0; i < 10; ++i) v.push_back(T<>(i));
  for (int i = 0; i < 5; ++i) v.pop_back();
  LOG("After interleaved: ", v, "\n");
  v.shrink_to_fit();
  LOG("After final shrink: ", v, "\n");
}

// =============================================================================
// AI TESTS: PART 2 - BORDER CASES & ALIASING
// =============================================================================

// 1. ALIASING (CRITICAL)
// Pushing or inserting an element that is already a reference to an element
// within the vector. If the vector reallocates before copying, the reference
// becomes dangling.
DUCK_TEST(Aliasing, PushBackSelf) {
  Vector<T<>> v;
  v.push_back(T<>(10));
  v.reserve(1);  // Force it to be near capacity if possible

  LOG("Before self-push: ", v, "\n");
  // v[0] is passed by reference. If push_back reallocates first, &v[0] is
  // invalid.
  v.push_back(v[0]);
  LOG("After self-push: ", v, "\n");
}

DUCK_TEST(Aliasing, InsertSelf) {
  Vector<T<>> v{1, 2, 3};
  LOG("Before self-insert: ", v, "\n");
  // Inserting an element from the vector into itself
  v.insert(v.begin() + 1, v[2]);
  LOG("After self-insert: ", v, "\n");
}

// 2. REVERSE ITERATORS
DUCK_TEST(Iterators, Reverse) {
  Vector<T<>> v{1, 2, 3, 4, 5};
  LOG("Reverse order: ");
  for (auto it = v.rbegin(); it != v.rend(); ++it) {
    LOG(*it, " ");
  }
  LOG("\n");
}

#include <list>
// 3. RANGE CONSTRUCTION FROM VARIOUS TYPES
DUCK_TEST(Constructor, RangeFromList) {
  std::list<int> l{10, 20, 30};
  // Construction from non-random-access iterators
  Vector<T<>> v(l.begin(), l.end());
  LOG("From list: ", v, "\n");
}

// 4. ASSIGNMENT STRESS
DUCK_TEST(Assignment, RangeAssign) {
  Vector<T<>> v{1, 2, 3};
  std::vector<T<>> src{10, 20, 30, 40, 50};

  LOG("Before assign: ", v, "\n");
  v.assign(src.begin(), src.end());
  LOG("After range assign: ", v, "\n");

  v.assign(2, T<>(99));
  LOG("After count assign: ", v, "\n");
}

// 5. CAPACITY VS SIZE DYNAMICS
DUCK_TEST(Memory, ReserveNoShrink) {
  Vector<T<>> v(10, T<>(1));
  size_t initialCap = v.capacity();
  LOG("Initial cap: ", initialCap, "\n");

  v.reserve(5);  // Should not shrink capacity
  LOG("Cap after reserve(5): ", v.capacity(), "\n");

  v.reserve(20);  // Should grow
  LOG("Cap after reserve(20): ", v.capacity(), "\n");
}

// 6. CLEAR AND REUSE
DUCK_TEST(Memory, ClearAndReuse) {
  Vector<T<>> v{1, 2, 3};
  v.clear();
  LOG("Cleared size: ", v.size(), " Cap: ", v.capacity(), "\n");

  v.push_back(T<>(100));
  LOG("After reuse: ", v, "\n");
}

// 7. FRONT/BACK ON SINGLETON
DUCK_TEST(Access, FrontBackSingle) {
  Vector<T<>> v;
  v.push_back(T<>(777));
  LOG("Front: ", v.front(), " Back: ", v.back(), "\n");

  v.front().val = 888;
  LOG("Modified Front: ", v[0], "\n");
}

// 8. CONST CORRECTNESS (COMPILE-TIME CHECK)
DUCK_TEST(Access, ConstAccess) {
  Vector<T<>> v{1, 2, 3};
  const Vector<T<>>& cv = v;
  LOG("Const Data: ");
  for (size_t i = 0; i < cv.size(); ++i) {
    LOG(cv[i], " ");
  }
  LOG("\nConst begin/end: ", *cv.begin(), " ", *(cv.end() - 1), "\n");
}

// 9. SWAP
DUCK_TEST(Modifiers, Swap) {
  Vector<T<>> v1{1, 2, 3};
  Vector<T<>> v2{10, 20};

  LOG("v1 before swap: ", v1, "\n");
  LOG("v2 before swap: ", v2, "\n");

  v1.swap(v2);

  LOG("v1 after swap: ", v1, "\n");
  LOG("v2 after swap: ", v2, "\n");

  std::swap(v1, v2);
  LOG("v1 after std::swap: ", v1, "\n");
}

// 10. LARGE GROWTH
DUCK_TEST(Stress, PushBackLarge) {
  Vector<T<>> v;
  // Push enough to trigger multiple doublings
  for (int i = 0; i < 33; ++i) {
    v.push_back(T<>(i));
  }
  LOG("Size: ", v.size(), " Cap: ", v.capacity(), "\n");
}

// =============================================================================
// AI TESTS: PART 3 - EDGE CASES, EXCEPTIONS & OPERATORS
// =============================================================================

// 1. RELATIONAL OPERATORS
DUCK_TEST(Operators, Comparisons) {
  Vector<T<>> v1{1, 2, 3};
  Vector<T<>> v2{1, 2, 3};
  Vector<T<>> v3{1, 2, 4};
  Vector<T<>> v4{1, 2};

  if (v1 == v2) LOG("v1 == v2\n");
  if (v1 != v3) LOG("v1 != v3\n");
  if (v4 < v1) LOG("v4 < v1 (shorter is smaller)\n");
  if (v3 > v1) LOG("v3 > v1 (element-wise)\n");
}

// 2. STRONG EXCEPTION GUARANTEE: PUSH_BACK
// If push_back fails during reallocation, the vector should remain unchanged.
DUCK_TEST(Exceptions, PushBackStrongGuarantee) {
  using ThrowyT = T<{.copyConstructorCanThrow = true}>;
  Vector<ThrowyT> v;
  v.push_back(ThrowyT(1));
  v.push_back(ThrowyT(2));

  size_t oldSize = v.size();
  size_t oldCap = v.capacity();

  LOG("Attempting push_back that might fail during growth...\n");
  try {
    // Force a growth that triggers a throwing copy
    // Note: This assumes the vector needs to copy existing elements to a new
    // block
    ThrowyT risky(3);
    v.push_back(risky);
  } catch (...) {
    LOG("Caught! Verifying vector state is unchanged...\n");
    if (v.size() == oldSize && v.capacity() == oldCap) {
      LOG("Strong Guarantee met: Vector state preserved.\n");
    }
  }
}

// 3. RANGE ASSIGNMENT (OVERLAPPING/SELF-ASSIGN)
DUCK_TEST(Assignment, RangeAssignSelf) {
  Vector<T<>> v{1, 2, 3, 4, 5};
  LOG("Before self-assign range: ", v, "\n");

  // Assigning a sub-range of itself to itself
  // A robust implementation must handle this without invalidated iterators
  v.assign(v.begin() + 1, v.begin() + 3);
  LOG("After self-assign range [1,3): ", v, "\n");
}

// 4. INSERTING MULTIPLE ELEMENTS
DUCK_TEST(Modifiers, InsertCount) {
  Vector<T<>> v{1, 5};
  LOG("Before count insert: ", v, "\n");

  // Insert three '10's at index 1
  v.insert(v.begin() + 1, 3, T<>(10));
  LOG("After count insert: ", v, "\n");
}

// 5. INSERTING VIA RANGE (INPUT ITERATORS)
DUCK_TEST(Modifiers, InsertRange) {
  std::list<int> l{10, 11, 12};
  Vector<T<>> v{1, 2, 3};

  v.insert(v.begin() + 1, l.begin(), l.end());
  LOG("After range insert from list: ", v, "\n");
}

// 6. AT() BOUNDS CHECKING
DUCK_TEST(Access, AtWithExceptions) {
  Vector<T<>> v{1, 2};
  LOG("at(0): ", v.at(0), "\n");
  try {
    (void)v.at(100);
  } catch (const std::out_of_range& e) {
    LOG("Caught expected out_of_range: ", e.what(), "\n");
  }
}

// 7. CLEARING AN ALREADY EMPTY VECTOR
DUCK_TEST(Memory, ClearEmptyTwice) {
  Vector<T<>> v;
  v.clear();
  v.clear();
  LOG("Double clear on empty successful. Size: ", v.size(), "\n");
}

// 8. RESIZE TO EXACT CAPACITY
DUCK_TEST(Memory, ResizeToCapacity) {
  Vector<T<>> v;
  v.reserve(10);
  v.resize(10, T<>(5));
  LOG("Resized to capacity: ", v, "\n");
  if (v.size() == v.capacity()) LOG("Size equals capacity\n");
}

// 9. SHRINK TO FIT ON FULL VECTOR
DUCK_TEST(Memory, ShrinkToFitFull) {
  Vector<T<>> v{1, 2, 3};
  // If size == capacity, shrink_to_fit should effectively do nothing
  // or at least not break anything.
  size_t cap = v.capacity();
  v.shrink_to_fit();
  LOG("Shrink to fit on full vector. Cap before/after: ", cap, "/",
      v.capacity(), "\n");
}

// 10. DESTRUCTOR SEMANTICS (MANUAL CHECK)
DUCK_TEST(Lifecycle, DestructorCallCount) {
  {
    Vector<T<>> v;
    v.push_back(T<>(1));
    v.push_back(T<>(2));
    v.push_back(T<>(3));
    LOG("Scope ending: Expecting 3 destructions...\n");
  }
  LOG("Scope ended.\n");
}

// 11. ASSIGNMENT FROM EMPTY INITIALIZER LIST
DUCK_TEST(Assignment, EmptyInitializerList) {
  Vector<T<>> v{1, 2, 3};
  v = {};
  LOG("After empty IL assignment: size=", v.size(), " cap=", v.capacity(),
      "\n");
}

// 12. MOVE ASSIGNMENT WITH DIFFERENT CAPACITIES
DUCK_TEST(Lifecycle, MoveAssignmentComplex) {
  Vector<T<>> v1(10, T<>(1));
  Vector<T<>> v2(2, T<>(2));

  LOG("Moving large vector into small vector...\n");
  v2 = std::move(v1);
  LOG("v2 size: ", v2.size(), " v1 size (should be 0): ", v1.size(), "\n");
}