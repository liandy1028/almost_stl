#include "DuckTest.h"

namespace DuckTest {
template <typename T>
  requires requires(T v) {
    v.begin();
    v.end();
  } && (!std::is_same_v<std::remove_cvref_t<T>, std::string>)
std::ostream& operator<<(std::ostream& os, const T& v) {
  for (const auto& elem : v) os << elem << " ";
  os << "(capacity:" << v.capacity() << ")";
  return os;
}
}  // namespace DuckTest

DUCK_TEST(Constructor, Sized) {
  Vector<T<>> v(3);
  LOG(v, "\n");
}

DUCK_TEST(Constructor, SizedWithValue) {
  Vector<T<>> v(3, T<>(42));
  LOG(v, "\n");
}

DUCK_TEST(Constructor, InitializerList) {
  Vector<T<>> v{T<>(1), T<>(2), T<>(3)};
  LOG(v, "\n");
}

DUCK_TEST(Constructor, Iterator) {
  std::vector<T<>> src{T<>(1), T<>(2), T<>(3)};
  Vector<T<>> v(src.begin(), src.end());
  LOG(v, "\n");
}

DUCK_TEST(Constructor, Copy) {
  Vector<T<>> v1(3, T<>(42));
  Vector<T<>> v2 = v1;
  LOG(v1, "\n");
  LOG(v2, "\n");
}

DUCK_TEST(Constructor, Move) {
  Vector<T<>> v1(3, T<>(42));
  Vector<T<>> v2 = std::move(v1);
  LOG(v1, "\n");
  LOG(v2, "\n");
}

DUCK_TEST(Assignment, SelfCopy) {
  Vector<T<>> v(2);
  v = v;
  LOG(v, "\n");
}

DUCK_TEST(Assignment, SelfMove) {
  Vector<T<>> v(2);
  v = std::move(v);
  LOG(v, "\n");
}

DUCK_TEST(Assignment, CopyDoesNotReallocate) {
  Vector<T<>> v1(3);
  Vector<T<>> v2(2);
  v1 = v2;
  LOG("v1: ", v1, "\n");
}

DUCK_TEST(Assignment, CopyReallocates) {
  Vector<T<>> v1(2);
  Vector<T<>> v2(3);
  v1 = v2;
  LOG("v1: ", v1, "\n");
  LOG("v2: ", v2, "\n");
}

DUCK_TEST(Assignment, Move) {
  Vector<T<>> v1(3);
  Vector<T<>> v2(2);
  v1 = std::move(v2);
  LOG("v1: ", v1, "\n");
  LOG("v2: ", v2, "\n");
}

DUCK_TEST(Clear, Basic) {
  Vector<T<>> v(3);
  LOG("Before clear: ", v, "\n");
  v.clear();
  LOG("After clear: ", v, "\n");
}

DUCK_TEST(Reserve, MoveObjects) {
  Vector<T<>> v{1, 2, 3};
  v.reserve(10);
  LOG(v, "\n");
}

DUCK_TEST(Growth, PushBack) {
  Vector<T<>> v;
  for (int i = 0; i < 10; ++i) {
    v.push_back(i);
    LOG(v, "\n");
  }
}

DUCK_TEST(Growth, Insert) {
  Vector<T<>> v;
  for (int i = 0; i < 10; ++i) {
    v.insert(v.begin(), i);
    LOG(v, "\n");
  }
}

DUCK_TEST(Growth, Insert2) {
  Vector<T<>> v;
  for (int i = 0; i < 10; ++i) {
    v.insert(v.begin(), 2, i);
    LOG(v, "\n");
  }
}

DUCK_TEST(Growth, Insert2at1of2) {
  Vector<T<>> v{0, 0};
  for (int i = 0; i < 10; ++i) {
    v.insert(v.begin() + 1, 2, i);
    LOG(v, "\n");
  }
}

DUCK_TEST(Growth, Insert2at1of1) {
  Vector<T<>> v{0};
  for (int i = 0; i < 10; ++i) {
    v.insert(v.begin() + 1, 2, i);
    LOG(v, "\n");
  }
}

DUCK_TEST(CopyVsMove, MoveIsThrowyButNoCopy) {
  using ThrowyT =
      T<{.enableCopyConstructor = false, .moveConstructorCanThrow = true}>;
  Vector<ThrowyT> v;
  v.push_back(ThrowyT(1));
  v.push_back(ThrowyT(2));
  v.reserve(v.capacity() + 10);
}

DUCK_TEST(Emplace, EmplaceIntoExisiting) {
  Vector<T<>> v{1, 2, 3};
  auto it = v.emplace(v.begin(), 0);
  LOG(*it, "\n");
  LOG(v, "\n");
}

DUCK_TEST(Emplace, EmplaceIntoExisitingNoReallocate) {
  Vector<T<>> v{1, 2, 3};
  v.reserve(10);
  auto it = v.emplace(v.begin(), 0);
  LOG(*it, "\n");
  LOG(v, "\n");
}

DUCK_TEST(Emplace, EmplaceIntoExisitingNoReallocateCannotMove) {
  using NoMoveT =
      T<{.enableMoveConstructor = false, .enableMoveAssignment = false}>;
  Vector<NoMoveT> v{1, 2, 3};
  v.reserve(10);
  auto it = v.emplace(v.begin(), 0);
  LOG(*it, "\n");
  LOG(v, "\n");
}

DUCK_TEST(Emplace, EmplaceIntoExisitingNoReallocateMoveCanThrow) {
  using ThrowyT = T<{.moveConstructorCanThrow = true}>;
  Vector<ThrowyT> v{1, 2, 3};
  v.reserve(10);
  auto it = v.emplace(v.begin(), 0);
  LOG(*it, "\n");
  LOG(v, "\n");
}

DUCK_TEST(Insert, InsertMoveCanThrow) {
  using ThrowyT = T<{.moveConstructorCanThrow = true}>;
  Vector<ThrowyT> v{1, 2, 3};
  v.reserve(10);
  auto it = v.insert(v.begin(), ThrowyT(0));
  LOG(*it, "\n");
  LOG(v, "\n");
}

// =============================================================================
// AI TESTS
// These tests were generated by AI
// =============================================================================

// =============================================================================
// 1. SIMPLE & BASIC API
// =============================================================================

DUCK_TEST(Simple, InitialState) {
  Vector<T<>> v;
  LOG("Size: ", v.size(), " Capacity: ", v.capacity(), " Empty: ", v.empty(),
      "\n");
}

DUCK_TEST(Simple, PushAndAccess) {
  Vector<T<>> v;
  v.push_back(T<>(10));
  v.push_back(T<>(20));
  LOG("Front: ", v.front(), " Back: ", v.back(), "\n");
  LOG("Index 0: ", v[0], " Index 1: ", v[1], "\n");
  if (v.data() == &v[0]) LOG("data() pointer is valid\n");
}

DUCK_TEST(Simple, ResizeBasic) {
  Vector<T<>> v;
  LOG("Resize up (default construct)\n");
  v.resize(3);
  LOG("Resize up (value 99)\n");
  v.resize(5, T<>(99));
  LOG("Resize down to 2\n");
  v.resize(2);
}

DUCK_TEST(Simple, ClearEmpty) {
  Vector<T<>> v(5);
  LOG("Size before clear: ", v.size(), "\n");
  v.clear();
  LOG("Size after clear: ", v.size(), " Empty: ", v.empty(), "\n");
}

// =============================================================================
// 2. LIFECYCLE (THE BIG FIVE)
// =============================================================================

DUCK_TEST(Lifecycle, Construction) {
  LOG("--- Sized Construction ---\n");
  Vector<T<>> v1(3);

  LOG("--- Copy Construction ---\n");
  Vector<T<>> v2 = v1;

  LOG("--- Move Construction ---\n");
  Vector<T<>> v3 = std::move(v1);
}

DUCK_TEST(Lifecycle, Assignment) {
  Vector<T<>> v1, v2;
  v1.push_back(T<>(1));
  v2.push_back(T<>(2));

  LOG("--- Copy Assignment ---\n");
  v1 = v2;

  LOG("--- Move Assignment ---\n");
  Vector<T<>> v3;
  v3 = std::move(v1);
}

DUCK_TEST(Lifecycle, SelfAssignment) {
  Vector<T<>> v;
  v.push_back(T<>(1));
  LOG("Self-copy\n");
  v = v;
  LOG("Self-move\n");
  v = std::move(v);
}

DUCK_TEST(Lifecycle, ShrinkToFit) {
  Vector<T<>> v;
  v.reserve(100);
  v.push_back(T<>(1));
  LOG("Capacity before: ", v.capacity(), "\n");
  v.shrink_to_fit();
  LOG("Capacity after: ", v.capacity(), "\n");
}

// =============================================================================
// 3. NOEXCEPT TRAIT LOGIC
// =============================================================================

DUCK_TEST(Traits, ReallocationCopyVsMove) {
  LOG("--- Scenario: Move is noexcept (Should MOVE) ---\n");
  {
    using SafeT = T<{.moveConstructorCanThrow = false}>;
    Vector<SafeT> v;
    v.push_back(SafeT(1));
    v.push_back(SafeT(2));
    v.reserve(v.capacity() + 10);
  }

  LOG("\n--- Scenario: Move can throw (Should COPY for Safety) ---\n");
  {
    using RiskyT = T<{.moveConstructorCanThrow = true}>;
    Vector<RiskyT> v;
    v.push_back(RiskyT(1));
    v.push_back(RiskyT(2));
    v.reserve(v.capacity() + 10);
  }
}

// =============================================================================
// 4. MODIFIERS & SHIFTING
// =============================================================================

DUCK_TEST(Modifiers, PopBack) {
  Vector<T<>> v;
  v.push_back(T<>(1));
  v.pop_back();  // Should destroy 1 element
  LOG("Size after pop: ", v.size(), "\n");
}

DUCK_TEST(Modifiers, InsertBoundaries) {
  Vector<T<>> v;
  v.push_back(T<>(10));
  LOG("Insert begin\n");
  v.insert(v.begin(), T<>(0));
  LOG("Insert end\n");
  v.insert(v.end(), T<>(20));
}

DUCK_TEST(Modifiers, InsertBoundaries2) {
  Vector<T<>> v;
  v.push_back(T<>(10));
  LOG("Insert begin\n");
  v.insert(v.begin(), T<>(0));
  LOG("Insert end\n");
  v.push_back(T<>(20));
}

DUCK_TEST(Modifiers, EraseSingleAndRange) {
  Vector<T<>> v;
  for (int i = 0; i < 5; ++i) v.push_back(T<>(i));

  LOG("Erase front\n");
  v.erase(v.begin());

  LOG("Erase range [1, 3)\n");
  v.erase(v.begin() + 1, v.begin() + 3);
}

DUCK_TEST(Modifiers, EmplaceBack) {
  Vector<T<>> v;
  v.emplace_back(123);  // Uses T(int)
  LOG("Back: ", v.back(), "\n");
}

// =============================================================================
// 5. STRESS & EXCEPTIONS
// =============================================================================

DUCK_TEST(Stress, Growth) {
  Vector<T<>> v;
  LOG("Pushing 20 elements to observe growth factor strategy\n");
  for (int i = 0; i < 20; ++i) {
    v.push_back(T<>(i));
    LOG("Cap: ", v.capacity(), " ");
  }
  LOG("\n");
}

DUCK_TEST(Stress, MoveOnlyType) {
  using MoveOnlyT =
      T<{.enableCopyConstructor = false, .enableCopyAssignment = false}>;
  Vector<MoveOnlyT> v;
  v.push_back(MoveOnlyT(1));
  v.reserve(10);  // Must move, cannot copy
  LOG("Move-only vector size: ", v.size(), "\n");
}

DUCK_TEST(Exception, ThrowOnCopy) {
  using ThrowyT = T<{.copyConstructorCanThrow = true}>;
  Vector<ThrowyT> v1;
  v1.push_back(ThrowyT(1));

  LOG("Attempting throwing copy construction\n");
  try {
    Vector<ThrowyT> v2 = v1;
  } catch (...) {
    LOG("Caught expected exception\n");
  }
}

// =============================================================================
// AI TESTS: SYSTEMATIC VALIDATION
// =============================================================================

// 1. REALLOCATION AND OVERLAP
DUCK_TEST(Modifiers, InsertAtCapacity) {
  Vector<T<>> v;
  v.reserve(2);
  v.push_back(T<>(10));
  v.push_back(T<>(20));
  LOG("Before insert: ", v, "\n");

  // Triggers reallocation + shifting
  v.insert(v.begin() + 1, T<>(15));
  LOG("After insert: ", v, "\n");
}

// 2. RANGE ERASE DYNAMICS
DUCK_TEST(Modifiers, EraseRangeEnd) {
  Vector<T<>> v{1, 2, 3, 4, 5};
  // Erase from middle to end
  auto it = v.erase(v.begin() + 2, v.end());
  LOG("After range erase: ", v, "\n");
  if (it == v.end()) LOG("Returned end iterator\n");
}

DUCK_TEST(Modifiers, EraseEntireVector) {
  Vector<T<>> v{1, 2, 3};
  v.erase(v.begin(), v.end());
  LOG("Empty after erase: ", v, " Size: ", v.size(), "\n");
}

// 3. RESIZE CORNER CASES
DUCK_TEST(Resize, ShrinkAndGrow) {
  Vector<T<>> v{1, 2, 3, 4, 5};
  LOG("Original: ", v, "\n");

  v.resize(2);
  LOG("Shrunk to 2: ", v, "\n");

  v.resize(4, T<>(99));
  LOG("Grown back to 4: ", v, "\n");

  v.resize(10);
  LOG("Grown to 10 (default): ", v, "\n");
}

// 4. ASSIGNMENT FLAVORS
DUCK_TEST(Assignment, InitializerListOverwriting) {
  Vector<T<>> v(10, T<>(1));
  LOG("Before IL assignment: ", v, "\n");

  v = {7, 8, 9};
  LOG("After IL assignment: ", v, "\n");
}

// 5. DATA STABILITY
DUCK_TEST(Access, DataPointerStability) {
  Vector<T<>> v{1, 2, 3};
  const T<>* ptr = v.data();
  LOG("First element via data(): ", *ptr, "\n");

  v.push_back(T<>(4));  // May reallocate
  if (v.data() != ptr) {
    LOG("Reallocation changed data pointer\n");
  }
  LOG("Vector after growth: ", v, "\n");
}

// 6. POP_BACK ON SINGLETON
DUCK_TEST(Modifiers, PopBackToEmpty) {
  Vector<T<>> v;
  v.push_back(T<>(42));
  LOG("Before pop: ", v, "\n");
  v.pop_back();
  LOG("After pop: ", v, " Size: ", v.size(), "\n");
}

// 7. ITERATOR ARITHMETIC LOGGING
DUCK_TEST(Iterators, Distances) {
  Vector<T<>> v{10, 20, 30, 40, 50};
  auto first = v.begin();
  auto last = v.end();
  auto mid = first + (last - first) / 2;

  LOG("Mid element: ", *mid, "\n");
  LOG("Distance from start: ", (mid - first), "\n");
  LOG("Distance to end: ", (last - mid), "\n");
}

// 8. EMPLACE VS PUSH
DUCK_TEST(Modifiers, EmplaceBackMultipleArgs) {
  // Assuming T<> can be constructed from an int
  Vector<T<>> v;
  v.emplace_back(1);
  v.emplace_back(2);
  LOG("Emplaced: ", v, "\n");
}

// 9. SHRINK TO FIT (NON-BINDING BUT TESTABLE)
DUCK_TEST(Memory, ShrinkToFitEmpty) {
  Vector<T<>> v;
  v.reserve(100);
  LOG("Cap before: ", v.capacity(), "\n");
  v.shrink_to_fit();
  LOG("Cap after: ", v.capacity(), "\n");
}

// 10. REPETITIVE PUSH_BACK (GROWTH STRATEGY)
DUCK_TEST(Stress, InterleavedPushPop) {
  Vector<T<>> v;
  for (int i = 0; i < 10; ++i) v.push_back(T<>(i));
  for (int i = 0; i < 5; ++i) v.pop_back();
  LOG("After interleaved: ", v, "\n");
  v.shrink_to_fit();
  LOG("After final shrink: ", v, "\n");
}

// =============================================================================
// AI TESTS: PART 2 - BORDER CASES & ALIASING
// =============================================================================

// 1. ALIASING (CRITICAL)
// Pushing or inserting an element that is already a reference to an element
// within the vector. If the vector reallocates before copying, the reference
// becomes dangling.
DUCK_TEST(Aliasing, PushBackSelf) {
  Vector<T<>> v;
  v.push_back(T<>(10));
  v.reserve(1);  // Force it to be near capacity if possible

  LOG("Before self-push: ", v, "\n");
  // v[0] is passed by reference. If push_back reallocates first, &v[0] is
  // invalid.
  v.push_back(v[0]);
  LOG("After self-push: ", v, "\n");
}

DUCK_TEST(Aliasing, InsertSelf) {
  Vector<T<>> v{1, 2, 3};
  LOG("Before self-insert: ", v, "\n");
  // Inserting an element from the vector into itself
  v.insert(v.begin() + 1, v[2]);
  LOG("After self-insert: ", v, "\n");
}

// 2. REVERSE ITERATORS
DUCK_TEST(Iterators, Reverse) {
  Vector<T<>> v{1, 2, 3, 4, 5};
  LOG("Reverse order: ");
  for (auto it = v.rbegin(); it != v.rend(); ++it) {
    LOG(*it, " ");
  }
  LOG("\n");
}

#include <list>
// 3. RANGE CONSTRUCTION FROM VARIOUS TYPES
DUCK_TEST(Constructor, RangeFromList) {
  std::list<int> l{10, 20, 30};
  // Construction from non-random-access iterators
  Vector<T<>> v(l.begin(), l.end());
  LOG("From list: ", v, "\n");
}

// 4. ASSIGNMENT STRESS
DUCK_TEST(Assignment, RangeAssign) {
  Vector<T<>> v{1, 2, 3};
  std::vector<T<>> src{10, 20, 30, 40, 50};

  LOG("Before assign: ", v, "\n");
  v.assign(src.begin(), src.end());
  LOG("After range assign: ", v, "\n");

  v.assign(2, T<>(99));
  LOG("After count assign: ", v, "\n");
}

// 5. CAPACITY VS SIZE DYNAMICS
DUCK_TEST(Memory, ReserveNoShrink) {
  Vector<T<>> v(10, T<>(1));
  size_t initialCap = v.capacity();
  LOG("Initial cap: ", initialCap, "\n");

  v.reserve(5);  // Should not shrink capacity
  LOG("Cap after reserve(5): ", v.capacity(), "\n");

  v.reserve(20);  // Should grow
  LOG("Cap after reserve(20): ", v.capacity(), "\n");
}

// 6. CLEAR AND REUSE
DUCK_TEST(Memory, ClearAndReuse) {
  Vector<T<>> v{1, 2, 3};
  v.clear();
  LOG("Cleared size: ", v.size(), " Cap: ", v.capacity(), "\n");

  v.push_back(T<>(100));
  LOG("After reuse: ", v, "\n");
}

// 7. FRONT/BACK ON SINGLETON
DUCK_TEST(Access, FrontBackSingle) {
  Vector<T<>> v;
  v.push_back(T<>(777));
  LOG("Front: ", v.front(), " Back: ", v.back(), "\n");

  v.front().val = 888;
  LOG("Modified Front: ", v[0], "\n");
}

// 8. CONST CORRECTNESS (COMPILE-TIME CHECK)
DUCK_TEST(Access, ConstAccess) {
  Vector<T<>> v{1, 2, 3};
  const Vector<T<>>& cv = v;
  LOG("Const Data: ");
  for (size_t i = 0; i < cv.size(); ++i) {
    LOG(cv[i], " ");
  }
  LOG("\nConst begin/end: ", *cv.begin(), " ", *(cv.end() - 1), "\n");
}

// 9. SWAP
DUCK_TEST(Modifiers, Swap) {
  Vector<T<>> v1{1, 2, 3};
  Vector<T<>> v2{10, 20};

  LOG("v1 before swap: ", v1, "\n");
  LOG("v2 before swap: ", v2, "\n");

  v1.swap(v2);

  LOG("v1 after swap: ", v1, "\n");
  LOG("v2 after swap: ", v2, "\n");

  std::swap(v1, v2);
  LOG("v1 after std::swap: ", v1, "\n");
}

// 10. LARGE GROWTH
DUCK_TEST(Stress, PushBackLarge) {
  Vector<T<>> v;
  // Push enough to trigger multiple doublings
  for (int i = 0; i < 33; ++i) {
    v.push_back(T<>(i));
  }
  LOG("Size: ", v.size(), " Cap: ", v.capacity(), "\n");
}

// =============================================================================
// AI TESTS: PART 3 - EDGE CASES, EXCEPTIONS & OPERATORS
// =============================================================================

// 1. RELATIONAL OPERATORS
DUCK_TEST(Operators, Comparisons) {
  Vector<T<>> v1{1, 2, 3};
  Vector<T<>> v2{1, 2, 3};
  Vector<T<>> v3{1, 2, 4};
  Vector<T<>> v4{1, 2};

  if (v1 == v2) LOG("v1 == v2\n");
  if (v1 != v3) LOG("v1 != v3\n");
  if (v4 < v1) LOG("v4 < v1 (shorter is smaller)\n");
  if (v3 > v1) LOG("v3 > v1 (element-wise)\n");
}

// 2. STRONG EXCEPTION GUARANTEE: PUSH_BACK
// If push_back fails during reallocation, the vector should remain unchanged.
DUCK_TEST(Exceptions, PushBackStrongGuarantee) {
  using ThrowyT = T<{.copyConstructorCanThrow = true}>;
  Vector<ThrowyT> v;
  v.push_back(ThrowyT(1));
  v.push_back(ThrowyT(2));

  size_t oldSize = v.size();
  size_t oldCap = v.capacity();

  LOG("Attempting push_back that might fail during growth...\n");
  try {
    // Force a growth that triggers a throwing copy
    // Note: This assumes the vector needs to copy existing elements to a new
    // block
    ThrowyT risky(3);
    v.push_back(risky);
  } catch (...) {
    LOG("Caught! Verifying vector state is unchanged...\n");
    if (v.size() == oldSize && v.capacity() == oldCap) {
      LOG("Strong Guarantee met: Vector state preserved.\n");
    }
  }
}

// 3. RANGE ASSIGNMENT (OVERLAPPING/SELF-ASSIGN)
DUCK_TEST(Assignment, RangeAssignSelf) {
  Vector<T<>> v{1, 2, 3, 4, 5};
  LOG("Before self-assign range: ", v, "\n");

  // Assigning a sub-range of itself to itself
  // A robust implementation must handle this without invalidated iterators
  v.assign(v.begin() + 1, v.begin() + 3);
  LOG("After self-assign range [1,3): ", v, "\n");
}

// 4. INSERTING MULTIPLE ELEMENTS
DUCK_TEST(Modifiers, InsertCount) {
  Vector<T<>> v{1, 5};
  LOG("Before count insert: ", v, "\n");

  // Insert three '10's at index 1
  v.insert(v.begin() + 1, 3, T<>(10));
  LOG("After count insert: ", v, "\n");
}

// 5. INSERTING VIA RANGE (INPUT ITERATORS)
DUCK_TEST(Modifiers, InsertRange) {
  std::list<int> l{10, 11, 12};
  Vector<T<>> v{1, 2, 3};

  v.insert(v.begin() + 1, l.begin(), l.end());
  LOG("After range insert from list: ", v, "\n");
}

// 6. AT() BOUNDS CHECKING
DUCK_TEST(Access, AtWithExceptions) {
  Vector<T<>> v{1, 2};
  LOG("at(0): ", v.at(0), "\n");
  try {
    (void)v.at(100);
  } catch (const std::out_of_range& e) {
    LOG("Caught expected out_of_range: ", e.what(), "\n");
  }
}

// 7. CLEARING AN ALREADY EMPTY VECTOR
DUCK_TEST(Memory, ClearEmptyTwice) {
  Vector<T<>> v;
  v.clear();
  v.clear();
  LOG("Double clear on empty successful. Size: ", v.size(), "\n");
}

// 8. RESIZE TO EXACT CAPACITY
DUCK_TEST(Memory, ResizeToCapacity) {
  Vector<T<>> v;
  v.reserve(10);
  v.resize(10, T<>(5));
  LOG("Resized to capacity: ", v, "\n");
  if (v.size() == v.capacity()) LOG("Size equals capacity\n");
}

// 9. SHRINK TO FIT ON FULL VECTOR
DUCK_TEST(Memory, ShrinkToFitFull) {
  Vector<T<>> v{1, 2, 3};
  // If size == capacity, shrink_to_fit should effectively do nothing
  // or at least not break anything.
  size_t cap = v.capacity();
  v.shrink_to_fit();
  LOG("Shrink to fit on full vector. Cap before/after: ", cap, "/",
      v.capacity(), "\n");
}

// 10. DESTRUCTOR SEMANTICS (MANUAL CHECK)
DUCK_TEST(Lifecycle, DestructorCallCount) {
  {
    Vector<T<>> v;
    v.push_back(T<>(1));
    v.push_back(T<>(2));
    v.push_back(T<>(3));
    LOG("Scope ending: Expecting 3 destructions...\n");
  }
  LOG("Scope ended.\n");
}

// 11. ASSIGNMENT FROM EMPTY INITIALIZER LIST
DUCK_TEST(Assignment, EmptyInitializerList) {
  Vector<T<>> v{1, 2, 3};
  v = {};
  LOG("After empty IL assignment: size=", v.size(), " cap=", v.capacity(),
      "\n");
}

// 12. MOVE ASSIGNMENT WITH DIFFERENT CAPACITIES
DUCK_TEST(Lifecycle, MoveAssignmentComplex) {
  Vector<T<>> v1(10, T<>(1));
  Vector<T<>> v2(2, T<>(2));

  LOG("Moving large vector into small vector...\n");
  v2 = std::move(v1);
  LOG("v2 size: ", v2.size(), " v1 size (should be 0): ", v1.size(), "\n");
}

// =============================================================================
// AI TESTS: PART 4 - MAX COVERAGE (NON-MEMBER & CORNER CASES)
// =============================================================================

// 1. C++20 NON-MEMBER ERASURE
DUCK_TEST(NonMember, EraseValue) {
  Vector<T<>> v{1, 2, 3, 2, 4, 2, 5};
  auto removed_count = erase(v, T<>(2));
  LOG("Removed: ", removed_count, " Vector: ", v, "\n");
}

DUCK_TEST(NonMember, EraseIf) {
  Vector<T<>> v{1, 2, 3, 4, 5, 6};
  // Erase only even values
  auto removed_count = erase_if(v, [](const T<>& x) { return x.val % 2 == 0; });
  LOG("Removed count: ", removed_count, " Remaining: ", v, "\n");
}

// 2. SPACESHIP OPERATOR & LEXICOGRAPHICAL COMPARISON
DUCK_TEST(Operators, ComparisonsDeep) {
  Vector<T<>> v1{1, 2, 3};
  Vector<T<>> v2{1, 2, 3};
  Vector<T<>> v3{1, 2};
  Vector<T<>> v4{1, 2, 4};

  if ((v1 <=> v2) == std::strong_ordering::equal) LOG("v1 == v2\n");
  if ((v3 <=> v1) == std::strong_ordering::less) LOG("v3 < v1 (prefix)\n");
  if ((v4 <=> v1) == std::strong_ordering::greater)
    LOG("v4 > v1 (element diff)\n");
}

// 3. MID-VECTOR MODIFICATIONS
DUCK_TEST(Modifiers, EmplaceMid) {
  Vector<T<>> v{1, 3};
  auto it = v.emplace(v.begin() + 1, 2);
  LOG("After emplace: ", v, " Returned iterator points to: ", *it, "\n");
}

DUCK_TEST(Modifiers, InsertRValueOverload) {
  Vector<T<>> v{1, 2};
  T<> val(0);
  v.insert(v.begin(), std::move(val));  // Specifically tests T&& overload
  LOG("After rvalue insert: ", v, "\n");
}

// 4. ITERATOR DISPATCH (INPUT vs FORWARD)
#include <iterator>
#include <sstream>
DUCK_TEST(Constructor, InputIteratorPath) {
  std::istringstream iss("10 20 30");
  std::istream_iterator<int> start(iss), end;

  // This triggers the path that cannot use std::distance (size is unknown)
  Vector<T<>> v(start, end);
  LOG("From Input Iterator (stream): ", v, "\n");

  // Compared to std::distance
  Vector<T<>> v2{1, 2, 3};
}

// 5. CONST & REVERSE ITERATOR FULL COVERAGE
DUCK_TEST(Iterators, AllFlavors) {
  Vector<T<>> v{1, 2, 3};
  LOG("cbegin: ", *v.cbegin(), "\n");
  LOG("crbegin: ", *v.crbegin(), "\n");
  LOG("crend - 1: ", *(v.crend() - 1), "\n");

  if (v.begin() == v.cbegin()) LOG("begin and cbegin match\n");
}

// 6. CAPACITY LIMITS & EDGE CASES
DUCK_TEST(Capacity, MaxSize) {
  Vector<T<>> v;
  if (v.max_size() > 0) LOG("Max size reported: ", v.max_size(), "\n");
  Vector<int> v_int;
  if (v_int.max_size() > 0)
    LOG("Max size for int vector: ", v_int.max_size(), "\n");
  Vector<char> v_char;
  if (v_char.max_size() > 0)
    LOG("Max size for char vector: ", v_char.max_size(), "\n");
  Vector<double> v_double;
  if (v_double.max_size() > 0)
    LOG("Max size for double vector: ", v_double.max_size(), "\n");
}

DUCK_TEST(Memory, ReserveNoOp) {
  Vector<T<>> v{1, 2, 3};
  size_t old_cap = v.capacity();
  v.reserve(old_cap);      // Should do nothing
  v.reserve(old_cap / 2);  // Should do nothing
  LOG("Cap stable: ", v.capacity() == old_cap, "\n");
}

// 7. DATA POINTER ON EMPTY
DUCK_TEST(Access, EmptyDataPointer) {
  Vector<T<>> v;
  if (v.data() == nullptr || v.size() == 0) {
    LOG("Empty vector data() handled safely\n");
  }
}

// 8. RANGE ASSIGNMENT (FORWARD ITERATOR)
DUCK_TEST(Assignment, RangeAssignForward) {
  Vector<T<>> v;
  std::vector<int> src{100, 200, 300};
  v.assign(src.begin(), src.end());
  LOG("After range assign: ", v, "\n");
}

// 9. SWAP (NON-MEMBER)
DUCK_TEST(NonMember, Swap) {
  Vector<T<>> v1{1};
  Vector<T<>> v2{2};
  swap(v1, v2);
  LOG("v1: ", v1, " v2: ", v2, "\n");
}

// =============================================================================
// AI TESTS: PART 5 - SINGLE-PASS ITERATORS & RETURN VALUE VALIDATION
// =============================================================================

// 1. SINGLE-PASS RANGE ASSIGN (The "use-once" bug)
#include <iterator>
#include <sstream>
DUCK_TEST(Assignment, RangeAssignSinglePass) {
  Vector<T<>> v{1, 2, 3, 4, 5};
  std::istringstream iss("10 20");
  std::istream_iterator<int> start(iss), end;

  // This must work without calling std::distance.
  // It should clear the vector and then grow dynamically.
  v.assign(start, end);

  LOG("After single-pass assign: ", v, " Size: ", v.size(), "\n");
  if (v.size() == 2 && v[0].val == 10) LOG("Assign success\n");
}

// 2. SINGLE-PASS RANGE INSERT
DUCK_TEST(Modifiers, InsertRangeSinglePass) {
  Vector<T<>> v{1, 5};
  std::istringstream iss("2 3 4");
  std::istream_iterator<int> start(iss), end;

  LOG("Before single-pass insert: ", v, "\n");

  // Inserting single-pass iterators into the middle.
  // Implementation must likely buffer or shift carefully since size is unknown.
  auto it = v.insert(v.begin() + 1, start, end);

  LOG("After single-pass insert: ", v, "\n");
  LOG("Return iterator points to: ", *it, " (expected 2)\n");
}

// 3. RETURN VALUE VALIDATION (INSERT/EMPLACE)
DUCK_TEST(Modifiers, ReturnValueValidation) {
  Vector<T<>> v{10, 30};

  // insert(pos, value) returns iterator to inserted element
  auto it1 = v.insert(v.begin() + 1, T<>(20));
  if (*it1 == 20) LOG("insert(val) return valid\n");

  LOG("Vector after single insert: ", v, "\n");

  // insert(pos, count, value) returns iterator to first inserted element
  auto it2 = v.insert(v.begin() + 1, 2, T<>(15));
  if (*it2 == 15 && *(it2 + 1) == 15) LOG("insert(count) return valid\n");

  LOG("Vector after inserts: ", v, "\n");

  // emplace(pos, args) returns iterator to emplaced element
  auto it3 = v.emplace(v.end(), 40);
  if (*it3 == 40) LOG("emplace return valid\n");

  LOG("vector: ", v, "\n");

  // emplace_back returns reference to the element
  auto& ref = v.emplace_back(50);
  ref = 55;
  if (v.back().val == 55) LOG("emplace_back reference valid\n");
  LOG("After emplace_back: ", v, "\n");
}

// 4. MAX_SIZE AND CAPACITY LIMITS
DUCK_TEST(Capacity, MaxSizeAndReserve) {
  Vector<T<>> v;
  size_t m = v.max_size();
  LOG("Reporting max_size: ", m, "\n");

  // Try to reserve something impossible
  try {
    v.reserve(m + 1);
    LOG("Error: Should have thrown length_error\n");
  } catch (const std::length_error& e) {
    LOG("Caught expected length_error: ", e.what(), "\n");
  }
}

// 5. ERASE RETURN VALUES
DUCK_TEST(Modifiers, EraseReturnValues) {
  Vector<T<>> v{1, 2, 3, 4};

  // Erase single: returns iterator following the removed element
  auto it1 = v.erase(v.begin() + 1);  // removes '2'
  LOG("After single erase, it points to: ", *it1, " (expected 3)\n");

  // Erase range: returns iterator following the last removed element
  auto it2 = v.erase(v.begin(), v.begin() + 2);  // removes '1', '3'
  if (it2 == v.begin() && *it2 == 4) LOG("Range erase return valid\n");

  // Erase last element
  auto it3 = v.erase(v.end() - 1);
  if (it3 == v.end()) LOG("Erase last returns end()\n");
}

// 6. ASSIGNMENT OPERATOR RETURNS
DUCK_TEST(Assignment, OperatorReturnValues) {
  Vector<T<>> v1, v2, v3;
  v1 = {1, 2, 3};

  // Check chained assignment: v3 = v2 = v1
  v3 = v2 = v1;
  if (v3.size() == 3 && v2.size() == 3) LOG("Chained copy assignment works\n");

  // Check move assignment return
  v3 = std::move(v1);
  LOG("Move assignment return valid\n");
}

// 7. SWAP SYMMETRY
DUCK_TEST(Modifiers, SwapSelfAndEmpty) {
  Vector<T<>> v1{1, 2, 3};
  Vector<T<>> v2;

  v1.swap(v1);  // Self swap
  LOG("Size after self-swap: ", v1.size(), "\n");

  v1.swap(v2);  // Swap with empty
  LOG("After swap with empty, v1 size: ", v1.size(), " v2 size: ", v2.size(),
      "\n");
}

// =============================================================================
// AI TESTS: PART 6 - STRESS, EXCEPTION SAFETY & ITERATOR STABILITY
// =============================================================================

// 1. INSERT WITH ALIASING (Inserting from itself during reallocation)
DUCK_TEST(Aliasing, InsertRangeFromSelf) {
  Vector<T<>> v{1, 2, 3};
  v.reserve(3);  // Ensure we are at capacity

  LOG("Before self-range insert: ", v, "\n");
  // If this triggers a reallocation, the range [begin, end] becomes invalid
  // while the function is still trying to read from it.
  v.insert(v.begin() + 1, v.begin(), v.end());
  LOG("After self-range insert: ", v, "\n");
}

// 2. SHRINK_TO_FIT (The "No-Op" and "Actual-Action" cases)
DUCK_TEST(Memory, ShrinkToFitExhaustive) {
  Vector<T<>> v;
  v.reserve(100);
  v.push_back(T<>(1));

  LOG("Cap before shrink: ", v.capacity(), "\n");
  v.shrink_to_fit();
  LOG("Cap after shrink: ", v.capacity(), " (Expected: 1)\n");

  // Shrinking an already tight vector
  v.shrink_to_fit();
  LOG("Cap after redundant shrink: ", v.capacity(), "\n");
}

// 3. AT() CONST VS NON-CONST
DUCK_TEST(Access, AtConstexprManual) {
  Vector<T<>> v{1, 2, 3};
  const Vector<T<>>& cv = v;

  v.at(0).val = 10;  // Non-const
  if (cv.at(0).val == 10) LOG("at() const/non-const mapping valid\n");

  try {
    (void)cv.at(5);
  } catch (const std::out_of_range&) {
    LOG("Const at() throws correctly\n");
  }
}

// 4. RESIZE DOWN AND UP (Lifecycle Check)
DUCK_TEST(Lifecycle, ResizeBoundary) {
  Vector<T<>> v(10, T<>(1));
  LOG("Resizing 10 -> 2 (should destroy 8)\n");
  v.resize(2);
  LOG("Resizing 2 -> 5 (should construct 3)\n");
  v.resize(5, T<>(99));

  if (v.size() == 5 && v[4].val == 99) LOG("Resize state valid\n");
}

// 5. ASSIGNMENT: INITIALIZER LIST (Self-Assignment)
DUCK_TEST(Assignment, InitializerListOverlaps) {
  Vector<T<>> v{1, 2, 3};
  // Assigning from an IL that contains values... this is rarely a bug
  // but good for coverage of operator=(initializer_list).
  v = {4, 5, 6, 7};
  LOG("After IL override: ", v, " Size: ", v.size(), "\n");
}

// 6. ITERATOR SUBTRACTION AND COMPARISON
DUCK_TEST(Iterators, Arithmetic) {
  Vector<T<>> v{1, 2, 3, 4, 5};
  auto it1 = v.begin() + 1;
  auto it2 = v.begin() + 4;

  LOG("Distance: ", it2 - it1, " (Expected: 3)\n");
  if (it1 < it2) LOG("it1 < it2 valid\n");
  if (it2 > it1) LOG("it2 > it1 valid\n");
}

// 7. EMPLACE_BACK REALLOCATION STRESS
DUCK_TEST(Stress, EmplaceBackGrowth) {
  Vector<T<>> v;
  // This tests if emplace_back correctly handles the case where the
  // arguments passed are references to elements inside the vector
  // AND a reallocation happens.
  v.push_back(T<>(100));
  for (int i = 0; i < 10; ++i) {
    // If v[0] reallocates, the reference to v[0].val must remain valid
    // for the duration of the constructor call.
    v.emplace_back(v[0].val);
  }
  LOG("Vector after emplace growth: ", v.size(), " elements\n");
}

// 8. DATA() POINTER STABILITY ON MOVE
DUCK_TEST(Lifecycle, MovePointerStability) {
  Vector<T<>> v1{1, 2, 3};
  T<>* original_ptr = v1.data();

  Vector<T<>> v2 = std::move(v1);
  if (v2.data() == original_ptr) {
    LOG("Move construction successfully pilfered pointer\n");
  }
  if (v1.data() == nullptr || v1.size() == 0) {
    LOG("Source vector is now empty/null\n");
  }
}

// 9. ASSIGN SINGLE-PASS (EMPTY STREAM)
DUCK_TEST(Assignment, RangeAssignEmptySinglePass) {
  Vector<T<>> v{1, 2, 3};
  std::istringstream empty_iss("");
  std::istream_iterator<int> start(empty_iss), end;

  v.assign(start, end);
  LOG("After empty stream assign: size=", v.size(), "\n");
}